///////////////////////////////////////////////////
//                                               //
//         Components of HMFs                    //
//                                               //
///////////////////////////////////////////////////

/* We implement components of HMFs as multivariate polynomials. In the
   background, we think of arithmetic operations as operations modulo an ideal
   (generated by elements q^\nu for \nu outside the lower set cf. paper). In
   the code, we do not work with the ideal. Instead we use honest polynomial
   multiplications then discard unwanted coefficients.

   We provide two implementations: one that uses a multivariate (sparse)
   polynomial ring, and one that uses a tower of (dense) univariate polynomial
   rings. */

declare type ModFrmHilDEltComp;

declare attributes ModFrmHilDEltComp: CoefficientRing, // Rng
        Expansion, // RngMPolElt or RngUPolElt[...]
        LowerSetExpansion, //same
        InverseExpansion, //same; only set when a division is performed
        Precision, // RngIntElt - the maximum norm of nn for which coefficients are stored
        Space, // ModFrmHilD - the HMF space that this ModFrmHilDEltComp is a component in
        ComponentIdeal; // RngOrdIdl

HMF_DEFAULT_MULTIVARIATE := true;

///////////////////////////////////////////////////
//                                               //
//         Access to attributes                  //
//                                               //
///////////////////////////////////////////////////

intrinsic GradedRing(f :: ModFrmHilDEltComp) -> ModFrmHilDGRng
{}
    return Parent(f`Space);
end intrinsic;

intrinsic ExpansionRing(f :: ModFrmHilDEltComp) -> Rng
{}
    return Parent(Expansion(f));
end intrinsic;

intrinsic Level(f :: ModFrmHilDEltComp) -> RngOrdIdl
{}
    return Level(Space(f));
end intrinsic;

intrinsic IsMultivariate(f :: ModFrmHilDEltComp) -> BoolElt
{}
    return Type(Expansion(f)) eq RngMPolElt;
end intrinsic;

intrinsic CoefficientRing(f :: ModFrmHilDEltComp) -> Rng
{}
    return f`CoefficientRing;
end intrinsic;

intrinsic Expansion(f :: ModFrmHilDEltComp) -> RngElt
{}
    if not assigned f`Expansion and assigned f`LowerSetExpansion then
        HMFGetExpansionFromLowerSet(f);
    end if;
    return f`Expansion;
end intrinsic;

intrinsic LowerSetExpansion(f :: ModFrmHilDEltComp) -> RngElt
{}
    if not assigned f`LowerSetExpansion and assigned f`Expansion then
        HMFGetLowerSetFromExpansion(f);
    end if;
    return f`LowerSetExpansion;
end intrinsic;

intrinsic Precision(f :: ModFrmHilDEltComp) -> RngIntElt
{}
    return f`Precision;
end intrinsic;

intrinsic Space(f :: ModFrmHilDEltComp) -> ModFrmHilD
{}
    return f`Space;
end intrinsic;

intrinsic ComponentIdeal(f :: ModFrmHilDEltComp) -> RngOrdIdl
{}
    return f`ComponentIdeal;
end intrinsic;

intrinsic BaseField(f :: ModFrmHilDEltComp) -> FldNum
{}
    return BaseField(Space(f));
end intrinsic;

///////////////////////////////////////////////////
//                                               //
//         Access to coefficients                //
//                                               //
///////////////////////////////////////////////////

intrinsic Coefficient(f :: ModFrmHilDEltComp, nu :: FldNumElt
                      : InFunDomain := false) -> RngElt

{Returns the coefficient of nu in the Fourier series}

    M := GradedRing(f);
    bb := ComponentIdeal(f);
    n := Degree(BaseField(M));
    R := CoefficientRing(f);

    if not InFunDomain then
        nu, eps := FunDomainRep(M, nu);
    end if;
    b, prec := IsDefined(M`FunDomainReps[bb], nu);

    require b: "Not in fundamental domain";
    require prec le Precision(M): "Not enough precision";

    a :=  HMFExpansionCoefficient(Expansion(f), M`FunDomainRepsOfPrec[bb][prec][nu]);
    if not InFunDomain then
        uc := UnitCharacters(Space(f))[bb];
        a := a * Evaluate(uc, eps);
    end if;

    return a;
end intrinsic;

// specify two functions of HMFExpansionCoefficient for multivariate and univariate.
// if we choose only one of these implementations, can remove duplicate
intrinsic HMFExpansionCoefficient(f :: RngUPolElt, exp :: SeqEnum[RngIntElt]) -> RngElt

{Internal function: get coefficient of f with the given exponent}

    n := #exp;
    g := f;
    for i in [0..(n-1)] do
        g := Coefficient(g, exp[n - i]);
    end for;
    return g;
end intrinsic;

intrinsic HMFExpansionCoefficient(f :: RngMPolElt, exp :: SeqEnum[RngIntElt]) -> RngElt

{Internal function: get coefficient of f with the given exponent}

    P := Parent(f);
    mon := Monomial(P, exp);
    return MonomialCoefficient(f, mon);
end intrinsic;

intrinsic Coefficients(f :: ModFrmHilDEltComp) -> Assoc

{Returns an associative array nu->a_nu for nu in the fundamental domain
up to Precision(f).}

    M := GradedRing(f);
    bb := ComponentIdeal(f);
    coeffs := AssociativeArray();
    precs := [p: p in M`PrecisionsByComponent[bb] | p le Precision(f)];
    for p in precs do
        for nu->exp in M`FunDomainRepsOfPrec[bb][p] do
            coeffs[nu] := HMFExpansionCoefficient(Expansion(f), exp);
        end for;
    end for;
    return coeffs;

end intrinsic;

///////////////////////////////////////////////////
//                                               //
//         Printing                              //
//                                               //
///////////////////////////////////////////////////

intrinsic Print(f :: ModFrmHilDEltComp, level :: MonStgElt : num_coeffs := 10)
{}
    if level in ["Default", "Minimal", "Maximal"] then
        prec := Precision(f);
        bb := ComponentIdeal(f);
        M := GradedRing(f);
        precs := [p: p in M`PrecisionsByComponent[bb] | p le prec];
        printf "Hilbert modular form component for ideal class bb = %o at precision %o\n",
               IdealOneLine(bb), prec;
        printf "Coefficients (norm, nu)  |--->   a_nu:";
        count := 0;
        for p in precs do
            for nu->exp in M`FunDomainRepsOfPrec[bb][p] do
                printf "\n\t(%o, %o)  |--->   %o", p, nu,
                       HMFExpansionCoefficient(Expansion(f), exp);
                count +:= 1;
            end for;
            if count ge num_coeffs then
                printf "\n...";
                break;
            end if;
        end for;
        printf "\n";

    elif level eq "Magma" then
        error "not implemented yet!";
    else
        error "not a valid printing level.";
    end if;
end intrinsic;

///////////////////////////////////////////////////
//                                               //
//         Pruning the series                    //
//                                               //
///////////////////////////////////////////////////

intrinsic HMFExpansionSubset(f :: RngMPolElt, exps :: SeqEnum) -> RngMPolElt

{Internal function: extract only the specified exponents from the series}

    R := Parent(f);
    mons := [Monomial(R, e): e in exps];
    coeffs := [MonomialCoefficient(f, mon): mon in mons];
    return Polynomial(coeffs, mons);
end intrinsic;

intrinsic HMFExpansionSubset(f :: RngUPolElt, exps :: SeqEnum) -> RngUPolElt

{Internal function: extract only the specified exponents from the series}

    if #exps eq 0 then
        return Parent(f) ! 0;
    end if;

    n := #exps[1];
    P := Parent(f);
    last_entries := [e[n]: e in exps];
    new_coeffs := [BaseRing(P) ! 0: i in [0..Max(last_entries)]];

    if n eq 1 then
        for e in exps do
            new_coeffs[1 + e[1]] := Coefficient(f, e[1]);
        end for;
    else
        last_entries := SetToSequence(SequenceToSet(last_entries));
        for d in last_entries do
            rec_exps := [e[1..(n-1)]: e in exps | e[n] eq d];
            new_coeffs[1 + d] := HMFExpansionSubset(Coefficient(f, d), rec_exps);
        end for;
    end if;

    return P ! new_coeffs;
end intrinsic;

intrinsic HMFPruneExpansion(M :: ModFrmHilDGRng, bb :: RngOrdIdl, f :: RngElt :
                         prec := Precision(M)
    ) -> RngElt

{Internal function: returns a pruned version of the series f}

    exps := [];
    precs := [p: p in M`PrecisionsByComponent[bb] | p le prec];
    for p in precs do
        for nu->e in M`FunDomainRepsOfPrec[bb][p] do
            Append(~exps, e);
        end for;
    end for;
    return HMFExpansionSubset(f, exps);

end intrinsic;

intrinsic HMFPruneExpansion(f :: ModFrmHilDEltComp : prec := Precision(f))

{Internal function: replace f`Expansion by pruned version}

    f`Expansion := HMFPruneExpansion(GradedRing(f), ComponentIdeal(f), Expansion(f) :
                                     prec := prec);
end intrinsic;

intrinsic HMFPruneLowerSetExpansion(M :: ModFrmHilDGRng, bb :: RngOrdIdl, f :: RngElt :
                                    prec := Precision(M)
    ) -> RngElt

{Internal function: returns a pruned version of the lowerset series f}

    exps := [];
    precs := [p: p in M`PrecisionsByComponent[bb] | p le prec];
    for p in precs do
        for nu->exp_nu in M`FunDomainRepsOfPrec[bb][p] do
            for eps->e in M`LowerSet[bb][nu] do
                Append(~exps, e);
            end for;
        end for;
    end for;
    return HMFExpansionSubset(f, exps);

end intrinsic;

intrinsic HMFPruneLowerSetExpansion(f :: ModFrmHilDEltComp : prec := Precision(f))

{Internal function: replace f`LowerSetExpansion by pruned version}

    f`LowerSetExpansion := HMFPruneLowerSetExpansion(GradedRing(f), ComponentIdeal(f),
                                                     LowerSetExpansion(f) : prec := prec);
end intrinsic;

///////////////////////////////////////////////////
//                                               //
//         Expansion to lowerset and back        //
//                                               //
///////////////////////////////////////////////////

intrinsic HMFGetExpansionFromLowerSet(f :: ModFrmHilDEltComp)

{Internal function: compute f`Expansion from f`LowerSetExpansion}

    f`Expansion := HMFPruneExpansion(GradedRing(f), ComponentIdeal(f), f`LowerSetExpansion :
                                     prec := Precision(f));
end intrinsic;

intrinsic HMFGetLowerSetFromExpansion(f :: ModFrmHilDEltComp)

{Internal function: compute f`LowerSetExpansion from f`Expansion}

    M := GradedRing(f);
    bb := ComponentIdeal(f);
    uc := UnitCharacters(Space(f))[bb];

    exps := [];
    coeffs := [];
    precs := [p : p in M`PrecisionsByComponent[bb] | p le Precision(f)];
    for prec in precs do
        for nuprime->exp_nuprime in M`FunDomainRepsOfPrec[bb][prec] do
            a := HMFExpansionCoefficient(f`Expansion, exp_nuprime);
            for eps->exp_nu in M`LowerSet[bb][nuprime] do
                Append(~coeffs, a * Evaluate(uc, eps));
                Append(~exps, exp_nu);
            end for;
        end for;
    end for;

    f`LowerSetExpansion := HMFConstructExpansion(ExpansionRing(f), exps, coeffs);
end intrinsic;

intrinsic HMFConstructExpansion(R :: RngMPol, exps :: SeqEnum, coeffs :: SeqEnum[RngElt]
    ) -> RngMPolElt

{Internal function: construct the Fourier expansion with the specified
coefficients as an element of R}

    mons := [Monomial(R, e): e in exps];
    return Polynomial(coeffs, mons);
end intrinsic;

intrinsic HMFConstructExpansion(R :: RngUPol, exps :: SeqEnum, coeffs :: SeqEnum[RngElt]
    ) -> RngUPolElt

{Internal function: construct the Fourier expansion with the specified
coefficients as an element of R}

    if #exps eq 0 then
        return R ! 0;
    end if;

    n := #exps[1];
    last_entries := [e[n]: e in exps];
    pol_coeffs := [BaseRing(R) ! 0: i in [0..Max(last_entries)]];
    if n eq 1 then
        for i in [1..#exps] do
            pol_coeffs[1 + exps[i][1]] := coeffs[i];
        end for;
    else
        last_entries := SetToSequence(SequenceToSet(last_entries));
        for d in last_entries do
            rec_exps := [];
            rec_coeffs := [];
            for i in [1..#exps] do
                e := exps[i];
                if e[n] eq d then
                    Append(~rec_exps, e[1..(n-1)]);
                    Append(~rec_coeffs, coeffs[i]);
                end if;
            end for;
            pol_coeffs[1 + d] := HMFConstructExpansion(BaseRing(R), rec_exps, rec_coeffs);
        end for;
    end if;

    return R ! pol_coeffs;
end intrinsic;

///////////////////////////////////////////////////
//                                               //
//         ModFrmHilDEltComp constructors        //
//                                               //
///////////////////////////////////////////////////


intrinsic HMFExpansionRing(M::ModFrmHilDGRng, K::Rng :
                           Multivariate := HMF_DEFAULT_MULTIVARIATE) -> RngMPol
  {return cached PolynomialRing(K, n)}
  n := Degree(BaseField(M));
  if Multivariate then
    t := Sprint(Type(K));
    unique := t in ["FldRat", "RngInt"];
    b, R := IsDefined(M`RngMPol, t);
    if not b then
      if unique then
        R := PolynomialRing(K, n);
        M`RngMPol[t] := R;
      else
        M`RngMPol[t] := AssociativeArray();
      end if;
    end if;
    if not unique then // otherwise we already have R
      b, R := IsDefined(M`RngMPol[t], DefiningPolynomial(K));
      if not b then
        R := PolynomialRing(K, n);
        M`RngMPol[t][DefiningPolynomial(K)] := R;
      end if;
    end if;
  else
    R := K;
    for i in [1..n] do
        R := PolynomialRing(R);
    end for;
  end if;
  return R;
end intrinsic;

intrinsic HMFExpansionBaseRing(S :: RngMPol, n :: RngIntElt) -> Rng
{}
    return BaseRing(S);
end intrinsic;

intrinsic HMFExpansionBaseRing(S :: RngUPol, n :: RngIntElt) -> Rng
{}
    R := S;
    for i in [1..n] do
        R := BaseRing(R);
    end for;
    return R;
end intrinsic;

intrinsic HMFComponent(Mk :: ModFrmHilD, bb :: RngOrdIdl, f :: RngElt, prec :: RngIntElt :
                       LowerSet := false, Prune := true
    ) -> ModFrmHilDEltComp

{Internal function: constructs the HMF component whose Fourier series is
specified by the polynomial f at the given precision. Parent(f) should either
be a multivariate polynomial ring or a tower of univariate polynomial rings.}

    M := Parent(Mk);
    n := Degree(BaseField(Mk));
    R := HMFExpansionBaseRing(Parent(f), n);

    g := New(ModFrmHilDEltComp);
    g`Space := Mk;
    g`ComponentIdeal := bb;
    g`CoefficientRing := R;
    g`Precision := prec;
    if LowerSet then
        g`LowerSetExpansion := f;
    else
        g`Expansion := f;
    end if;

    if Prune then
        if LowerSet then
            HMFPruneLowerSetExpansion(g : prec := prec);
        else
            HMFPruneExpansion(g : prec := prec);
        end if;
    end if;
    return g;

end intrinsic;

intrinsic HMFComponent(Mk :: ModFrmHilD, bb :: RngOrdIdl, coeff_array :: Assoc
                       : Multivariate := HMF_DEFAULT_MULTIVARIATE,
                         CoefficientRing := DefaultCoefficientRing(Mk),
                         prec := Precision(Parent(Mk))
    ) -> ModFrmHilDEltComp

{Constructs the HMF component to precision prec whose Fourier coefficients are
specified by the given array indexed by nus in the fundamental domain.

By default, we assume that the coefficient ring is the default coefficient ring
of Mk, and that coefficients are specified up to the default precision of the
ambient graded ring. The user may specify another coefficient ring or a lower
precision instead.}

    M := Parent(Mk);
    n := Degree(BaseField(Mk));

    // Gather exponents and coefficients
    precs := [p: p in M`PrecisionsByComponent[bb] | p le prec];
    exps := [];
    coeffs := [];
    for p in precs do
        for nu->exp in M`FunDomainRepsOfPrec[bb][p] do
            b, coeff := IsDefined(coeff_array, nu);
            require b: "Coefficient not found for index: ", nu;
            Append(~exps, exp);
            Append(~coeffs, coeff);
        end for;
    end for;

    R := HMFExpansionRing(M, CoefficientRing : Multivariate := Multivariate);
    f := HMFConstructExpansion(R, exps, coeffs);
    return HMFComponent(Mk, bb, f, prec: LowerSet := false, Prune := false);

end intrinsic;

intrinsic HMFComponentZero(Mk::ModFrmHilD, bb::RngOrdIdl :
                           Multivariate := HMF_DEFAULT_MULTIVARIATE,
                           prec := Precision(Parent(Mk)),
                           coeff_ring := DefaultCoefficientRing(Mk)
    ) -> ModFrmHilDEltComp

{Returns the HMF component that is identically zero on the bb component.}

    n := Degree(BaseField(Mk));
    S := HMFExpansionRing(Parent(Mk), coeff_ring : Multivariate := Multivariate);
    return HMFComponent(Mk, bb, S ! 0, prec : LowerSet := true, Prune := false);
end intrinsic;

intrinsic HMFComponentIdentity(Mk :: ModFrmHilD, bb :: RngOrdIdl :
                               Multivariate := HMF_DEFAULT_MULTIVARIATE,
                               coeff_ring := DefaultCoefficientRing(Mk),
                               prec := Precision(Parent(Mk))) -> ModFrmHilDEltComp

{Returns the HMF component that is identically one on the bb component.}

    require &and[w eq 0: w in Weight(Mk)]: "Cannot construct HMF component equal to 1 in nonzero weight";
    n := Degree(BaseField(Mk));
    S := HMFExpansionRing(Parent(Mk), coeff_ring : Multivariate := Multivariate);
    return HMFComponent(Mk, bb, S ! 1, prec : LowerSet := true, Prune := false);
end intrinsic;

///////////////////////////////////////////////////
//                                               //
//         Arithmetic operations                 //
//                                               //
///////////////////////////////////////////////////

intrinsic ChangeRing(f :: ModFrmHilDEltComp, R :: Rng) -> ModFrmHilDEltComp

{Constructs the HMF component that is identical to f, except that its
coefficient ring is extended to R.}

    Mk := Space(f);
    M := Parent(Mk);
    n := Degree(BaseField(Mk));
    bb := ComponentIdeal(f);
    precs := [p: p in M`PrecisionsByComponent[bb] | p le Precision(f)];
    S := HMFExpansionRing(M, R : Multivariate := IsMultivariate(f));
    R := HMFExpansionBaseRing(S, n); //this may not be R!
    coeffs := [R| ];
    exps := [];
    ser := Expansion(f);
    for p in precs do
        for nu->exp in M`FunDomainRepsOfPrec[bb][p] do
            Append(~coeffs, StrongCoerce(R, HMFExpansionCoefficient(ser, exp)));
            Append(~exps, exp);
        end for;
    end for;
    ser := HMFConstructExpansion(S, exps, coeffs);
    return HMFComponent(Mk, bb, ser, Precision(f) : LowerSet := false, Prune := false);

end intrinsic;

intrinsic IsZero(f :: ModFrmHilDEltComp) -> BoolElt
{}
    return IsZero(Expansion(f));
end intrinsic;

intrinsic 'eq'(f :: ModFrmHilDEltComp, g :: ModFrmHilDEltComp) -> BoolElt
{}
    return Space(f) eq Space(g)
           and ComponentIdeal(f) eq ComponentIdeal(g)
           and CoefficientRing(f) eq CoefficientRing(g)
           and Precision(f) eq Precision(g)
           and Expansion(f) eq Expansion(g);
end intrinsic;

intrinsic '+'(f :: ModFrmHilDEltComp, g :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    require Space(f) eq Space(g) : "Cannot add HMF components from different spaces";
    require ComponentIdeal(f) eq ComponentIdeal(g): "Cannot add HMF components attached to different narrow class group representatives";

    bb := ComponentIdeal(f);
    prec := Min(Precision(f), Precision(g));
    prune := not (Precision(f) eq Precision(g));
    return HMFComponent(Space(f), ComponentIdeal(f), Expansion(f) + Expansion(g), prec
                        : LowerSet := false, Prune := prune);
end intrinsic;

intrinsic '*'(c :: RngElt, f :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    R := CoefficientRing(f);
    b, c_K := IsStrongCoercible(R, c);
    require b : "Cannot scale an HMF by a scalar not coercible into its coefficient field";

    return HMFComponent(Space(f), ComponentIdeal(f), c_K * Expansion(f), Precision(f)
                        : LowerSet := false, Prune := false);
end intrinsic;

intrinsic '-'(f :: ModFrmHilDEltComp, g :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    R := CoefficientRing(f);
    return f + R!(-1) * g;
end intrinsic;

intrinsic '*'(f :: ModFrmHilDEltComp, g :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    M := GradedRing(f);
    bb := ComponentIdeal(f);
    require M eq GradedRing(g): "Cannot multiply HMF components in different graded rings";
    require bb eq ComponentIdeal(g): "Cannot multiply HMF components on different components";
    Rf := CoefficientRing(f);
    Rg := CoefficientRing(g);
    if Rf ne Rg then
        Rfg := Compositum(Rf, Rg);
        return ChangeRing(f, Rfg) * ChangeRing(g, Rfg);
    end if;

    serf := LowerSetExpansion(f);
    serg := LowerSetExpansion(g);
    prec := Min(Precision(f), Precision(g));
    if Precision(f) gt prec then
        serf := HMFPruneLowerSetExpansion(M, bb, serf : Precision := prec);
    elif Precision(g) gt prec then
        serg := HMFPruneLowerSetExpansion(M, bb, serg : Precision := prec);
    end if;

    return HMFComponent(Space(f) * Space(g), bb, serf * serg, prec :
                        LowerSet := true, Prune := true);
end intrinsic;

intrinsic '^'(f :: ModFrmHilDEltComp, n :: RngIntElt) -> ModFrmHilDEltComp
{}
    require n ge 0: "Cannot compute inverse of HMF component";
    if n eq 0 then
        return HMFComponentIdentity(Space(f)^0, ComponentIdeal(f));
    end if;
    M := GradedRing(f);
    bb := ComponentIdeal(f);
    serf := LowerSetExpansion(f);
    prec := Precision(f);
    g := serf;
    bits := Intseq(n, 2);
    bits := Reverse(bits[1..(#bits - 1)]);
    for i in bits do
        g := g^2;
        g := HMFPruneLowerSetExpansion(M, bb, g : prec := prec);
        if i eq 1 then
            g := g * serf;
            g := HMFPruneLowerSetExpansion(M, bb, g : prec := prec);
        end if;
    end for;

    return HMFComponent(Space(f)^n, ComponentIdeal(f), g, prec :
                        LowerSet := true, Prune := false);
end intrinsic;

intrinsic InverseExpansion(f :: ModFrmHilDEltComp) -> RngElt
{}
    if not assigned f`InverseExpansion then
        M := GradedRing(f);
        n := Degree(BaseField(f));
        a0 := HMFExpansionCoefficient(Expansion(f), [0: i in [1..n]]);
        bb := ComponentIdeal(f);
        S := ExpansionRing(f);
        require IsInvertible(a0) : "Cannot divide if the constant coefficient is not invertible";

        a0inv := a0^(-1);
        serf := a0inv * LowerSetExpansion(f);
        u := 1 - serf;
        inv := S ! 1;
        while u ne 0 do
            inv := (1 + u) * inv;
            inv := HMFPruneLowerSetExpansion(M, bb, inv : prec := Precision(f));
            u := u * u;
            u := HMFPruneLowerSetExpansion(M, bb, u : prec := Precision(f));
        end while;
        f`InverseExpansion := a0inv * inv;
    end if;

    return f`InverseExpansion;
end intrinsic;

intrinsic '/'(f :: ModFrmHilDEltComp, g :: ModFrmHilDEltComp) -> ModFrmHilDEltComp
{}
    M := GradedRing(f);
    bb := ComponentIdeal(f);
    require M eq GradedRing(g): "Cannot divide HMF components in different graded rings";
    require bb eq ComponentIdeal(g) : "Cannot divide HMF components on different components";

    // Coerce automatically
    Rf := CoefficientRing(f);
    Rg := CoefficientRing(g);
    if Rf ne Rg then
        Rfg := Compositum(Rf, Rg);
        return ChangeRing(f, Rfg) / ChangeRing(g, Rfg);
    end if;

    serf := LowerSetExpansion(f);
    serg := InverseExpansion(g);
    prec := Min(Precision(f), Precision(g));
    if prec lt Precision(f) then
        serf := HMFPruneLowerSetExpansion(M, bb, serf : prec := prec);
    elif prec lt Precision(g) then
        serg := HMFPruneLowerSetExpansion(M, bb, serg : prec := prec);
    end if;

    res := serf * serg;
    res := HMFPruneLowerSetExpansion(M, bb, res : prec := prec);

    return HMFComponent(Space(f) / Space(g), bb, res, prec :
                        LowerSet := true, Prune := false);
end intrinsic;

///////////////////////////////////////////////////
//                                               //
//         Advanced operations                   //
//                                               //
///////////////////////////////////////////////////

intrinsic Trace(f :: ModFrmHilDEltComp) -> ModFrmHilDEltComp

{Returns the trace of f down to the default coefficient field of Space(f),
assuming that its coefficient ring is a number field.}

    R := CoefficientRing(f);
    K := DefaultCoefficientRing(Space(f));
    tracemap := map< R->K | x:->Trace(x, K) >;
    return MapCoefficients(tracemap, f);
end intrinsic;

intrinsic MapCoefficients(m :: Map, f :: ModFrmHilDEltComp) -> ModFrmHilDEltComp

{Returns the HMF component obtained by applying the map m to all coefficients of f}

    M := GradedRing(f);
    bb := ComponentIdeal(f);
    n := Degree(BaseField(f));
    new_ring := Codomain(m);
    new_series_ring := HMFExpansionRing(GradedRing(f), new_ring
                                        : Multivariate := IsMultivariate(f));

    precs := [p: p in M`PrecisionsByComponent[bb] | p le Precision(f)];
    exps := [];
    coeffs := [];
    for p in precs do
        for nu->e in M`FunDomainRepsOfPrec[bb][p] do
            Append(~exps, e);
            Append(~coeffs, m(HMFExpansionCoefficient(Expansion(f), e)));
        end for;
    end for;
    new_series := HMFConstructExpansion(new_series_ring, exps, coeffs);
    return HMFComponent(Space(f), ComponentIdeal(f), new_series, Precision(f):
                        LowerSet := false, Prune := false);
end intrinsic;

intrinsic Inclusion(f :: ModFrmHilDEltComp, Mk :: ModFrmHilD, mm :: RngOrdIdl
    ) -> ModFrmHilDEltComp

{Takes a form f(z) and produces f(mm*z) in Mk (of level NN) with component
ideal class [mm*bb].}

    Mk_f := Space(f);
    M_f := Parent(Mk_f);
    M := Parent(Mk);
    N1 := Level(Mk_f);
    N2 := Level(Mk);
    chi := Character(Mk);
    chif := Character(Mk_f);
    mf, pf := Modulus(chif);
    ZF := Integers(M);
    coeff_ring := CoefficientRing(f);

    require Weight(Mk_f) eq Weight(Mk): "Weight(f) is not equal to Weight(Mk)";
    require chif eq Restrict(chi, mf, pf): "Character(f) is not equal to Character(Mk)";
    require UnitCharacters(Mk_f) eq UnitCharacters(Mk): "UnitCharacters(f) is not equal to UnitCharacters(Mk)";
    require N2 subset N1: "Level of f does not divide level of Mk";
    require N2 subset mm: "Ideal mm does not divide level of Mk";

    bb := ComponentIdeal(f);
    mmbb := NarrowClassRepresentative(M, mm * bb);
    prec := Min(Norm(mm) * Precision(f), Precision(M));

    coeffs := AssociativeArray();
    mminv := mm^-1;
    mmbbpinv := (M`NarrowClassGroupRepsToIdealDual[mmbb])^(-1);
    for nn -> nu in IdealToRep(M)[mmbb] do
        if Norm(nu) * Norm(mmbbpinv) le prec and IsIntegral(nn * mminv) then
            coeffs[nu] := Coefficient(f, IdealToRep(M)[bb][ZF!!(nn*mminv)]
                                     : InFunDomain := true);
        else
            coeffs[nu] := coeff_ring ! 0;
        end if;
    end for;
    return HMFComponent(Mk, mmbb, coeffs:
                        Multivariate := IsMultivariate(f), CoefficientRing := coeff_ring,
                        prec := prec);
end intrinsic;
